{"version":3,"file":"parsel.js","sources":["../../parsel.ts"],"sourcesContent":["export const enum TokenType {\n  Class = 'class',\n  Attribute = 'attribute',\n  Id = 'id',\n  Type = 'type',\n  Universal = 'universal',\n  PseudoElement = 'pseudo-element',\n  PseudoClass = 'pseudo-class',\n  Comma = 'comma',\n  Combinator = 'combinator',\n}\n\nexport interface Tokens {\n  type: string;\n  content: string;\n  name: string;\n  namespace?: string;\n  value?: string;\n  pos: [number, number];\n  operator?: string;\n  argument?: string;\n  subtree?: AST;\n  caseSensitive?: 'i';\n  /**\n   * @internal\n   */\n  __changed?: boolean;\n}\n\nexport interface Complex {\n  type: 'complex';\n  combinator: string;\n  right: AST;\n  left: AST;\n}\n\nexport interface Compound {\n  type: 'compound';\n  list: Tokens[];\n}\n\nexport interface List {\n  type: 'list';\n  list: AST[];\n}\n\nexport type AST = Complex | Compound | List | Tokens;\n\nexport const TOKENS: Record<string, RegExp> = {\n  [TokenType.Attribute]:\n    /\\[\\s*(?:(?<namespace>(?:\\\\.|[-\\w\\P{ASCII}])+|\\*)?\\|)?(?<name>(?:\\\\.|[-\\w\\P{ASCII}])+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(\\s(?<caseSensitive>[iIsS]))?\\s*)?\\]/gu,\n  [TokenType.Id]: /#(?<name>(?:\\\\.|[-\\w\\P{ASCII}])+)/gu,\n  [TokenType.Class]: /\\.(?<name>(?:\\\\.|[-\\w\\P{ASCII}])+)/gu,\n  [TokenType.Comma]: /\\s*,\\s*/g, // must be before combinator\n  [TokenType.Combinator]: /\\s*[\\s>+~]\\s*/g, // this must be after attribute\n  [TokenType.PseudoElement]:\n    /::(?<name>(?:\\\\.|[-\\w\\P{ASCII}])+)(?:\\((?<argument>¶+)\\))?/gu, // this must be before pseudo-class\n  [TokenType.PseudoClass]:\n    /:(?<name>(?:\\\\.|[-\\w\\P{ASCII}])+)(?:\\((?<argument>¶+)\\))?/gu,\n  [TokenType.Universal]: /(?:(?<namespace>\\*|(?:\\\\.|[-\\w\\P{ASCII}])*)\\|)?\\*/gu,\n  [TokenType.Type]:\n    /(?:(?<namespace>\\*|(?:\\\\.|[-\\w\\P{ASCII}])*)\\|)?(?<name>(?:\\\\.|[-\\w\\P{ASCII}])+)/gu, // this must be last\n};\n\nexport const TOKENS_TO_TRIM = new Set<string>([\n  TokenType.Combinator,\n  TokenType.Comma,\n]);\n\nexport const RECURSIVE_PSEUDO_CLASSES = new Set<string>([\n  'not',\n  'is',\n  'where',\n  'has',\n  'matches',\n  '-moz-any',\n  '-webkit-any',\n  'nth-child',\n  'nth-last-child',\n]);\n\nconst nthChildRegExp = /(?<index>[\\dn+-]+)\\s+of\\s+(?<subtree>.+)/;\nexport const RECURSIVE_PSEUDO_CLASSES_ARGS: Record<string, RegExp> = {\n  'nth-child': nthChildRegExp,\n  'nth-last-child': nthChildRegExp,\n};\n\nconst getTokensForRestore = (type: string) => {\n  switch (type) {\n    case TokenType.PseudoElement:\n    case TokenType.PseudoClass:\n      return new RegExp(\n        TOKENS[type].source.replace('(?<argument>¶+)', '(?<argument>.+)'),\n        'gu'\n      );\n    default:\n      return TOKENS[type];\n  }\n};\n\nexport function tokenizeBy(text: string, grammar = TOKENS): Tokens[] {\n  if (!text) {\n    return [];\n  }\n\n  const tokens: (Tokens | string)[] = [text];\n  for (const type in grammar) {\n    const pattern = grammar[type];\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      if (typeof token !== 'string') {\n        continue;\n      }\n\n      pattern.lastIndex = 0;\n      const match = pattern.exec(token);\n      if (!match) {\n        continue;\n      }\n\n      const from = match.index - 1;\n      const args: (Tokens | string)[] = [];\n      const content = match[0];\n\n      const before = token.slice(0, from + 1);\n      if (before) {\n        args.push(before);\n      }\n\n      args.push({\n        ...(match.groups as unknown as Tokens),\n        type,\n        content,\n      });\n\n      const after = token.slice(from + content.length + 1);\n      if (after) {\n        args.push(after);\n      }\n\n      tokens.splice(i, 1, ...args);\n    }\n  }\n\n  let offset = 0;\n  for (const token of tokens) {\n    switch (typeof token) {\n      case 'string':\n        throw new Error(\n          `Unexpected sequence ${token} found at index ${offset}`\n        );\n      case 'object':\n        offset += token.content.length;\n        token.pos = [offset - token.content.length, offset];\n        if (TOKENS_TO_TRIM.has(token.type)) {\n          token.content = token.content.trim() || ' ';\n        }\n        break;\n    }\n  }\n\n  return tokens as Tokens[];\n}\n\nexport function tokenize(selector: string, grammar = TOKENS) {\n  type TokenString = {value: string; offset: number};\n\n  if (!selector) {\n    return null;\n  }\n\n  // Prevent leading/trailing whitespace be interpreted as combinators\n  selector = selector.trim();\n\n  const replacements: TokenString[] = [];\n\n  // Replace strings with whitespace strings (to preserve offsets)\n  {\n    const state: {\n      escaped: boolean;\n      quoteState?: [quoteType: string, offset: number];\n    } = {escaped: false};\n    for (let i = 0; i < selector.length; ++i) {\n      if (state.escaped) {\n        continue;\n      }\n      switch (selector[i]) {\n        case '\\\\':\n          state.escaped = true;\n          break;\n        case '\"':\n        case \"'\":\n          if (!state.quoteState) {\n            state.quoteState = [selector[i], i];\n            continue;\n          }\n          const quote = state.quoteState[0];\n          if (quote !== selector[i]) {\n            continue;\n          }\n          const offset = state.quoteState[1];\n          const value = selector.slice(state.quoteState[1], i + 1);\n          replacements.push({value, offset});\n          const replacement = `${quote}${'§'.repeat(value.length - 2)}${quote}`;\n          selector =\n            selector.slice(0, offset) +\n            replacement +\n            selector.slice(offset + value.length);\n          break;\n      }\n    }\n  }\n\n  // Now that strings are out of the way, extract parens and replace them with parens with whitespace (to preserve offsets)\n  {\n    const state: {\n      escaped: boolean;\n      nesting: number;\n      offset: number;\n    } = {escaped: false, nesting: 0, offset: 0};\n    for (let i = 0; i < selector.length; ++i) {\n      if (state.escaped) {\n        continue;\n      }\n      switch (selector[i]) {\n        case '\\\\':\n          state.escaped = true;\n          break;\n        case '(':\n          if (++state.nesting !== 1) {\n            continue;\n          }\n          state.offset = i;\n          break;\n        case ')':\n          if (--state.nesting !== 0) {\n            continue;\n          }\n          const {offset} = state;\n          const value = selector.slice(offset, i + 1);\n          replacements.push({value, offset});\n          const replacement = `(${'¶'.repeat(value.length - 2)})`;\n          selector =\n            selector.slice(0, offset) +\n            replacement +\n            selector.slice(offset + value.length);\n          break;\n      }\n    }\n  }\n\n  // Now we have no nested structures and we can parse with regexes\n  const tokens = tokenizeBy(selector, grammar);\n\n  // Restore replacements in reverse order.\n  for (const replacement of replacements.reverse()) {\n    for (const token of tokens) {\n      const {offset, value} = replacement;\n      if (!(token.pos[0] <= offset && offset + value.length <= token.pos[1])) {\n        continue;\n      }\n\n      // Invert replacements\n      const content = token.content;\n      const tokenOffset = offset - token.pos[0];\n      token.content =\n        content.slice(0, tokenOffset) +\n        value +\n        content.slice(tokenOffset + value.length);\n      token.__changed = token.content !== content;\n    }\n  }\n\n  // Rematch tokens with changed content.\n  for (const token of tokens) {\n    if (!token.__changed) {\n      continue;\n    }\n    delete token.__changed;\n\n    const pattern = getTokensForRestore(token.type);\n    pattern.lastIndex = 0;\n    const match = pattern.exec(token.content);\n    if (!match) {\n      throw new Error(\"This shouldn't be possible!\");\n    }\n    Object.assign(token, match.groups);\n  }\n\n  return tokens;\n}\n\n/**\n *  Convert a flat list of tokens into a tree of complex & compound selectors\n */\nfunction nestTokens(tokens: Tokens[]): AST {\n  {\n    const list: AST[] = [];\n    const {length} = tokens;\n    let offset = 0;\n    for (let limit = offset; limit !== length; ++limit) {\n      const token = tokens[limit];\n      if (token.type !== TokenType.Comma) {\n        continue;\n      }\n      list.push(nestTokens(tokens.slice(offset, limit)));\n      offset = limit + 1;\n    }\n    if (list.length !== 0) {\n      list.push(nestTokens(tokens.slice(offset)));\n      return {type: 'list', list};\n    }\n  }\n\n  for (let index = tokens.length - 1; index >= 0; --index) {\n    const token = tokens[index];\n    if (token.type !== TokenType.Combinator) {\n      continue;\n    }\n    const left = tokens.slice(0, index);\n    const right = tokens.slice(index + 1);\n\n    return {\n      type: 'complex',\n      combinator: token.content,\n      left: nestTokens(left),\n      right: nestTokens(right),\n    };\n  }\n\n  switch (tokens.length) {\n    case 0:\n      throw new Error('Could not build AST.');\n    case 1:\n      // If we're here, there are no combinators, so it's just a list.\n      return tokens[0];\n    default:\n      return {\n        type: 'compound',\n        list: [...tokens], // clone to avoid pointers messing up the AST\n      };\n  }\n}\n\n/**\n * Traverse an AST (or part thereof), in depth-first order\n *\n * @deprecated Use {@link flatten}.\n */\nexport function walk(\n  node: AST | undefined,\n  visit: (node: AST, parentNode?: AST) => void,\n  /**\n   * @internal\n   */\n  parent?: AST\n) {\n  for (const [n, p] of flatten(node, parent)) {\n    visit(n, p);\n  }\n}\n\n/**\n * Traverse an AST (or part thereof), in depth-first order\n */\nexport function* flatten(\n  node: AST | undefined,\n  /**\n   * @internal\n   */\n  parent?: AST\n): Generator<[node: AST, parent: AST | undefined]> {\n  if (!node) {\n    return;\n  }\n\n  if ('left' in node && 'right' in node) {\n    yield* flatten(node.left, node);\n    yield* flatten(node.right, node);\n  } else if ('list' in node) {\n    for (const child of node.list) {\n      yield* flatten(child, node);\n    }\n  }\n\n  yield [node, parent];\n}\n\nexport interface ParserOptions {\n  /**\n   * Whether to parse the arguments of pseudo-classes like :is(), :has() etc.\n   *\n   * @defaultValue `true`\n   */\n  recursive?: boolean;\n}\n\n/**\n * Parse a CSS selector\n *\n * @param selector - Selector to parse.\n * @param options - Configuration for parsing.\n */\nexport function parse(\n  selector: string,\n  {recursive = true}: ParserOptions = {}\n): AST | undefined {\n  const tokens = tokenize(selector);\n  if (!tokens) {\n    return;\n  }\n\n  const ast = nestTokens(tokens);\n  if (!recursive) {\n    return ast;\n  }\n\n  for (const [node] of flatten(ast)) {\n    if (node.type !== TokenType.PseudoClass || !node.argument) {\n      continue;\n    }\n    if (!RECURSIVE_PSEUDO_CLASSES.has(node.name)) {\n      continue;\n    }\n    let argument = node.argument;\n    const pattern = RECURSIVE_PSEUDO_CLASSES_ARGS[node.name];\n    if (pattern) {\n      const match = pattern.exec(argument);\n      if (!match) {\n        continue;\n      }\n\n      Object.assign(node, match.groups);\n      argument = match.groups!['subtree'];\n    }\n    if (argument) {\n      Object.assign(node, {\n        subtree: parse(argument, {recursive}),\n      });\n    }\n  }\n\n  return ast;\n}\n\n/**\n * To convert the specificity array to a number\n */\nexport function specificityToNumber(\n  specificity: number[],\n  base: number\n): number {\n  base = base || Math.max(...specificity) + 1;\n  return specificity[0] * (base << 1) + specificity[1] * base + specificity[2];\n}\n\n/**\n * Calculate specificity of a selector.\n *\n * If the selector is a list, the max specificity is returned.\n */\nexport function specificity(selector: string | AST): number[] {\n  let ast: string | AST | undefined = selector;\n  if (typeof ast === 'string') {\n    ast = parse(ast, {recursive: true});\n  }\n  if (!ast) {\n    return [];\n  }\n\n  if (ast.type === 'list' && 'list' in ast) {\n    let base = 10;\n    const specificities = ast.list.map(ast => {\n      const sp = specificity(ast);\n      base = Math.max(base, ...specificity(ast));\n      return sp;\n    });\n    const numbers = specificities.map(ast => specificityToNumber(ast, base));\n    return specificities[numbers.indexOf(Math.max(...numbers))];\n  }\n\n  const result = [0, 0, 0];\n  for (const [node] of flatten(ast)) {\n    switch (node.type) {\n      case TokenType.Id:\n        result[0]++;\n        break;\n      case TokenType.Class:\n      case TokenType.Attribute:\n        result[1]++;\n        break;\n      case TokenType.Type:\n      case TokenType.PseudoElement:\n        result[2]++;\n        break;\n      case TokenType.PseudoClass:\n        if (node.name === 'where') {\n          break;\n        }\n        if (!RECURSIVE_PSEUDO_CLASSES.has(node.name) || !node.subtree) {\n          result[1]++;\n          break;\n        }\n        for (const [index, sub] of specificity(node.subtree).entries()) {\n          result[index] += sub;\n        }\n        // :nth-child() & :nth-last-child() add (0, 1, 0) to the specificity of their most complex selector\n        if (node.name === 'nth-child' || node.name === 'nth-last-child') {\n          result[1]++;\n        }\n        break;\n    }\n  }\n\n  return result;\n}\n"],"names":[],"mappings":"IAAkB;AAAlB,WAAkB,SAAS;IACzB,4BAAe,CAAA;IACf,oCAAuB,CAAA;IACvB,sBAAS,CAAA;IACT,0BAAa,CAAA;IACb,oCAAuB,CAAA;IACvB,6CAAgC,CAAA;IAChC,yCAA4B,CAAA;IAC5B,4BAAe,CAAA;IACf,sCAAyB,CAAA;AAC3B,CAAC,EAViB,SAAS,KAAT,SAAS,QAU1B;MAsCY,MAAM,GAA2B;IAC5C,CAAC,SAAS,CAAC,SAAS,GAClB,uKAAuK;IACzK,CAAC,SAAS,CAAC,EAAE,GAAG,qCAAqC;IACrD,CAAC,SAAS,CAAC,KAAK,GAAG,sCAAsC;IACzD,CAAC,SAAS,CAAC,KAAK,GAAG,UAAU;IAC7B,CAAC,SAAS,CAAC,UAAU,GAAG,gBAAgB;IACxC,CAAC,SAAS,CAAC,aAAa,GACtB,8DAA8D;IAChE,CAAC,SAAS,CAAC,WAAW,GACpB,6DAA6D;IAC/D,CAAC,SAAS,CAAC,SAAS,GAAG,qDAAqD;IAC5E,CAAC,SAAS,CAAC,IAAI,GACb,mFAAmF;EACrF;MAEW,cAAc,GAAG,IAAI,GAAG,CAAS;IAC5C,SAAS,CAAC,UAAU;IACpB,SAAS,CAAC,KAAK;CAChB,EAAE;MAEU,wBAAwB,GAAG,IAAI,GAAG,CAAS;IACtD,KAAK;IACL,IAAI;IACJ,OAAO;IACP,KAAK;IACL,SAAS;IACT,UAAU;IACV,aAAa;IACb,WAAW;IACX,gBAAgB;CACjB,EAAE;AAEH,MAAM,cAAc,GAAG,0CAA0C,CAAC;MACrD,6BAA6B,GAA2B;IACnE,WAAW,EAAE,cAAc;IAC3B,gBAAgB,EAAE,cAAc;EAChC;AAEF,MAAM,mBAAmB,GAAG,CAAC,IAAY;IACvC,QAAQ,IAAI;QACV,KAAK,SAAS,CAAC,aAAa,CAAC;QAC7B,KAAK,SAAS,CAAC,WAAW;YACxB,OAAO,IAAI,MAAM,CACf,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,iBAAiB,EAAE,iBAAiB,CAAC,EACjE,IAAI,CACL,CAAC;QACJ;YACE,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC;KACvB;AACH,CAAC,CAAC;SAEc,UAAU,CAAC,IAAY,EAAE,OAAO,GAAG,MAAM;IACvD,IAAI,CAAC,IAAI,EAAE;QACT,OAAO,EAAE,CAAC;KACX;IAED,MAAM,MAAM,GAAwB,CAAC,IAAI,CAAC,CAAC;IAC3C,KAAK,MAAM,IAAI,IAAI,OAAO,EAAE;QAC1B,MAAM,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;QAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACtC,MAAM,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACxB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;gBAC7B,SAAS;aACV;YAED,OAAO,CAAC,SAAS,GAAG,CAAC,CAAC;YACtB,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAClC,IAAI,CAAC,KAAK,EAAE;gBACV,SAAS;aACV;YAED,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC;YAC7B,MAAM,IAAI,GAAwB,EAAE,CAAC;YACrC,MAAM,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAEzB,MAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,GAAG,CAAC,CAAC,CAAC;YACxC,IAAI,MAAM,EAAE;gBACV,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aACnB;YAED,IAAI,CAAC,IAAI,CAAC;gBACR,GAAI,KAAK,CAAC,MAA4B;gBACtC,IAAI;gBACJ,OAAO;aACR,CAAC,CAAC;YAEH,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACrD,IAAI,KAAK,EAAE;gBACT,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aAClB;YAED,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC;SAC9B;KACF;IAED,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;QAC1B,QAAQ,OAAO,KAAK;YAClB,KAAK,QAAQ;gBACX,MAAM,IAAI,KAAK,CACb,uBAAuB,KAAK,mBAAmB,MAAM,EAAE,CACxD,CAAC;YACJ,KAAK,QAAQ;gBACX,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC;gBAC/B,KAAK,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;gBACpD,IAAI,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;oBAClC,KAAK,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,GAAG,CAAC;iBAC7C;gBACD,MAAM;SACT;KACF;IAED,OAAO,MAAkB,CAAC;AAC5B,CAAC;SAEe,QAAQ,CAAC,QAAgB,EAAE,OAAO,GAAG,MAAM;IAGzD,IAAI,CAAC,QAAQ,EAAE;QACb,OAAO,IAAI,CAAC;KACb;;IAGD,QAAQ,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;IAE3B,MAAM,YAAY,GAAkB,EAAE,CAAC;;IAGvC;QACE,MAAM,KAAK,GAGP,EAAC,OAAO,EAAE,KAAK,EAAC,CAAC;QACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YACxC,IAAI,KAAK,CAAC,OAAO,EAAE;gBACjB,SAAS;aACV;YACD,QAAQ,QAAQ,CAAC,CAAC,CAAC;gBACjB,KAAK,IAAI;oBACP,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC;oBACrB,MAAM;gBACR,KAAK,GAAG,CAAC;gBACT,KAAK,GAAG;oBACN,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;wBACrB,KAAK,CAAC,UAAU,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;wBACpC,SAAS;qBACV;oBACD,MAAM,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBAClC,IAAI,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,EAAE;wBACzB,SAAS;qBACV;oBACD,MAAM,MAAM,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBACnC,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;oBACzD,YAAY,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,MAAM,EAAC,CAAC,CAAC;oBACnC,MAAM,WAAW,GAAG,GAAG,KAAK,GAAG,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,KAAK,EAAE,CAAC;oBACtE,QAAQ;wBACN,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC;4BACzB,WAAW;4BACX,QAAQ,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;oBACxC,MAAM;aACT;SACF;KACF;;IAGD;QACE,MAAM,KAAK,GAIP,EAAC,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAC,CAAC;QAC5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YACxC,IAAI,KAAK,CAAC,OAAO,EAAE;gBACjB,SAAS;aACV;YACD,QAAQ,QAAQ,CAAC,CAAC,CAAC;gBACjB,KAAK,IAAI;oBACP,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC;oBACrB,MAAM;gBACR,KAAK,GAAG;oBACN,IAAI,EAAE,KAAK,CAAC,OAAO,KAAK,CAAC,EAAE;wBACzB,SAAS;qBACV;oBACD,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;oBACjB,MAAM;gBACR,KAAK,GAAG;oBACN,IAAI,EAAE,KAAK,CAAC,OAAO,KAAK,CAAC,EAAE;wBACzB,SAAS;qBACV;oBACD,MAAM,EAAC,MAAM,EAAC,GAAG,KAAK,CAAC;oBACvB,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;oBAC5C,YAAY,CAAC,IAAI,CAAC,EAAC,KAAK,EAAE,MAAM,EAAC,CAAC,CAAC;oBACnC,MAAM,WAAW,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC;oBACxD,QAAQ;wBACN,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC;4BACzB,WAAW;4BACX,QAAQ,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;oBACxC,MAAM;aACT;SACF;KACF;;IAGD,MAAM,MAAM,GAAG,UAAU,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;;IAG7C,KAAK,MAAM,WAAW,IAAI,YAAY,CAAC,OAAO,EAAE,EAAE;QAChD,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;YAC1B,MAAM,EAAC,MAAM,EAAE,KAAK,EAAC,GAAG,WAAW,CAAC;YACpC,IAAI,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,MAAM,IAAI,MAAM,GAAG,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;gBACtE,SAAS;aACV;;YAGD,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;YAC9B,MAAM,WAAW,GAAG,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAC1C,KAAK,CAAC,OAAO;gBACX,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,WAAW,CAAC;oBAC7B,KAAK;oBACL,OAAO,CAAC,KAAK,CAAC,WAAW,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC;YAC5C,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,OAAO,KAAK,OAAO,CAAC;SAC7C;KACF;;IAGD,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;QAC1B,IAAI,CAAC,KAAK,CAAC,SAAS,EAAE;YACpB,SAAS;SACV;QACD,OAAO,KAAK,CAAC,SAAS,CAAC;QAEvB,MAAM,OAAO,GAAG,mBAAmB,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAChD,OAAO,CAAC,SAAS,GAAG,CAAC,CAAC;QACtB,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QAC1C,IAAI,CAAC,KAAK,EAAE;YACV,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;SAChD;QACD,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;KACpC;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;AAGA,SAAS,UAAU,CAAC,MAAgB;IAClC;QACE,MAAM,IAAI,GAAU,EAAE,CAAC;QACvB,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,CAAC;QACxB,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,KAAK,IAAI,KAAK,GAAG,MAAM,EAAE,KAAK,KAAK,MAAM,EAAE,EAAE,KAAK,EAAE;YAClD,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;YAC5B,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,CAAC,KAAK,EAAE;gBAClC,SAAS;aACV;YACD,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;YACnD,MAAM,GAAG,KAAK,GAAG,CAAC,CAAC;SACpB;QACD,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;YACrB,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAC5C,OAAO,EAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAC,CAAC;SAC7B;KACF;IAED,KAAK,IAAI,KAAK,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,EAAE,KAAK,EAAE;QACvD,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;QAC5B,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,CAAC,UAAU,EAAE;YACvC,SAAS;SACV;QACD,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;QACpC,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC;QAEtC,OAAO;YACL,IAAI,EAAE,SAAS;YACf,UAAU,EAAE,KAAK,CAAC,OAAO;YACzB,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC;YACtB,KAAK,EAAE,UAAU,CAAC,KAAK,CAAC;SACzB,CAAC;KACH;IAED,QAAQ,MAAM,CAAC,MAAM;QACnB,KAAK,CAAC;YACJ,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;QAC1C,KAAK,CAAC;;YAEJ,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;QACnB;YACE,OAAO;gBACL,IAAI,EAAE,UAAU;gBAChB,IAAI,EAAE,CAAC,GAAG,MAAM,CAAC;aAClB,CAAC;KACL;AACH,CAAC;AAED;;;;;SAKgB,IAAI,CAClB,IAAqB,EACrB,KAA4C;AAC5C;;;AAGA,MAAY;IAEZ,KAAK,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE;QAC1C,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;KACb;AACH,CAAC;AAED;;;UAGiB,OAAO,CACtB,IAAqB;AACrB;;;AAGA,MAAY;IAEZ,IAAI,CAAC,IAAI,EAAE;QACT,OAAO;KACR;IAED,IAAI,MAAM,IAAI,IAAI,IAAI,OAAO,IAAI,IAAI,EAAE;QACrC,OAAO,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAChC,OAAO,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;KAClC;SAAM,IAAI,MAAM,IAAI,IAAI,EAAE;QACzB,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,IAAI,EAAE;YAC7B,OAAO,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;SAC7B;KACF;IAED,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;AACvB,CAAC;AAWD;;;;;;SAMgB,KAAK,CACnB,QAAgB,EAChB,EAAC,SAAS,GAAG,IAAI,KAAmB,EAAE;IAEtC,MAAM,MAAM,GAAG,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAClC,IAAI,CAAC,MAAM,EAAE;QACX,OAAO;KACR;IAED,MAAM,GAAG,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC;IAC/B,IAAI,CAAC,SAAS,EAAE;QACd,OAAO,GAAG,CAAC;KACZ;IAED,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,EAAE;QACjC,IAAI,IAAI,CAAC,IAAI,KAAK,SAAS,CAAC,WAAW,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YACzD,SAAS;SACV;QACD,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YAC5C,SAAS;SACV;QACD,IAAI,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC7B,MAAM,OAAO,GAAG,6BAA6B,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACzD,IAAI,OAAO,EAAE;YACX,MAAM,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACrC,IAAI,CAAC,KAAK,EAAE;gBACV,SAAS;aACV;YAED,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;YAClC,QAAQ,GAAG,KAAK,CAAC,MAAO,CAAC,SAAS,CAAC,CAAC;SACrC;QACD,IAAI,QAAQ,EAAE;YACZ,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE;gBAClB,OAAO,EAAE,KAAK,CAAC,QAAQ,EAAE,EAAC,SAAS,EAAC,CAAC;aACtC,CAAC,CAAC;SACJ;KACF;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAED;;;SAGgB,mBAAmB,CACjC,WAAqB,EACrB,IAAY;IAEZ,IAAI,GAAG,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC;IAC5C,OAAO,WAAW,CAAC,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;AAC/E,CAAC;AAED;;;;;SAKgB,WAAW,CAAC,QAAsB;IAChD,IAAI,GAAG,GAA6B,QAAQ,CAAC;IAC7C,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;QAC3B,GAAG,GAAG,KAAK,CAAC,GAAG,EAAE,EAAC,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;KACrC;IACD,IAAI,CAAC,GAAG,EAAE;QACR,OAAO,EAAE,CAAC;KACX;IAED,IAAI,GAAG,CAAC,IAAI,KAAK,MAAM,IAAI,MAAM,IAAI,GAAG,EAAE;QACxC,IAAI,IAAI,GAAG,EAAE,CAAC;QACd,MAAM,aAAa,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG;YACpC,MAAM,EAAE,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC;YAC5B,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;YAC3C,OAAO,EAAE,CAAC;SACX,CAAC,CAAC;QACH,MAAM,OAAO,GAAG,aAAa,CAAC,GAAG,CAAC,GAAG,IAAI,mBAAmB,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;QACzE,OAAO,aAAa,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;KAC7D;IAED,MAAM,MAAM,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACzB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,EAAE;QACjC,QAAQ,IAAI,CAAC,IAAI;YACf,KAAK,SAAS,CAAC,EAAE;gBACf,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC;gBACZ,MAAM;YACR,KAAK,SAAS,CAAC,KAAK,CAAC;YACrB,KAAK,SAAS,CAAC,SAAS;gBACtB,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC;gBACZ,MAAM;YACR,KAAK,SAAS,CAAC,IAAI,CAAC;YACpB,KAAK,SAAS,CAAC,aAAa;gBAC1B,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC;gBACZ,MAAM;YACR,KAAK,SAAS,CAAC,WAAW;gBACxB,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;oBACzB,MAAM;iBACP;gBACD,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;oBAC7D,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC;oBACZ,MAAM;iBACP;gBACD,KAAK,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,IAAI,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;oBAC9D,MAAM,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC;iBACtB;;gBAED,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW,IAAI,IAAI,CAAC,IAAI,KAAK,gBAAgB,EAAE;oBAC/D,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC;iBACb;gBACD,MAAM;SACT;KACF;IAED,OAAO,MAAM,CAAC;AAChB;;;;"}