{"version":3,"file":"parsel.js","sources":["../../../parsel.ts"],"sourcesContent":["export const enum TokenType {\n  Class = 'class',\n  Attribute = 'attribute',\n  Id = 'id',\n  Type = 'type',\n  Universal = 'universal',\n  PseudoElement = 'pseudo-element',\n  PseudoClass = 'pseudo-class',\n  Comma = 'comma',\n  Combinator = 'combinator'\n}\n\nexport interface Tokens {\n  type: string;\n  content: string;\n  name: string;\n  namespace?: string;\n  value?: string;\n  pos: [number, number];\n  operator?: string;\n  argument?: string;\n  subtree?: AST;\n  caseSensitive?: 'i';\n}\n\nexport interface Complex {\n  type: 'complex';\n  combinator: string;\n  right: AST;\n  left: AST;\n}\n\nexport interface Compound {\n  type: 'compound';\n  list: Tokens[];\n}\n\nexport interface List {\n  type: 'list';\n  list: AST[];\n}\n\nexport type AST = Complex | Compound | List | Tokens;\n\nexport const TOKENS: Record<string, RegExp> = {\n  [TokenType.Attribute]:\n    /\\[\\s*(?:(?<namespace>\\*|[-\\w]*)\\|)?(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(\\s(?<caseSensitive>[iIsS]))?\\s*)?\\]/gu,\n  [TokenType.Id]: /#(?<name>(?:\\\\.|[-\\w\\u{0080}-\\u{FFFF}])+)/gu,\n  [TokenType.Class]: /\\.(?<name>(?:\\\\.|[-\\w\\u{0080}-\\u{FFFF}])+)/gu,\n  [TokenType.Comma]: /\\s*,\\s*/g, // must be before combinator\n  [TokenType.Combinator]: /\\s*[\\s>+~]\\s*/g, // this must be after attribute\n  [TokenType.PseudoElement]:\n    /::(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)(?:\\((?<argument>¶+)\\))?/gu, // this must be before pseudo-class\n  [TokenType.PseudoClass]:\n    /:(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)(?:\\((?<argument>¶+)\\))?/gu,\n  [TokenType.Universal]: /(?:(?<namespace>\\*|[-\\w]*)\\|)?\\*/gu,\n  [TokenType.Type]:\n    /(?:(?<namespace>\\*|[-\\w]*)\\|)?(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)|\\*/gu // this must be last\n};\n\nexport const TOKENS_WITH_PARENS = new Set<string>([\n  TokenType.PseudoClass,\n  TokenType.PseudoElement\n]);\nexport const TOKENS_WITH_STRINGS = new Set<string>([\n  ...TOKENS_WITH_PARENS,\n  TokenType.Attribute\n]);\nexport const TOKENS_TO_TRIM = new Set<string>([\n  TokenType.Combinator,\n  TokenType.Comma\n]);\n\nexport const RECURSIVE_PSEUDO_CLASSES = new Set<string>([\n  'not',\n  'is',\n  'where',\n  'has',\n  'matches',\n  '-moz-any',\n  '-webkit-any',\n  'nth-child',\n  'nth-last-child'\n]);\n\nconst nthChildRegExp = /(?<index>[\\dn+-]+)\\s+of\\s+(?<subtree>.+)/;\nexport const RECURSIVE_PSEUDO_CLASSES_ARGS: Record<string, RegExp> = {\n  'nth-child': nthChildRegExp,\n  'nth-last-child': nthChildRegExp\n};\n\nconst TOKENS_FOR_RESTORE = { ...TOKENS };\nfor (const pseudoType of [\n  TokenType.PseudoElement,\n  TokenType.PseudoClass\n] as const) {\n  TOKENS_FOR_RESTORE[pseudoType] = RegExp(\n    TOKENS[pseudoType].source.replace('(?<argument>¶+)', '(?<argument>.+)'),\n    'gu'\n  );\n}\n\nfunction scanParentheses(text: string, offset: number): string {\n  let nesting = 0;\n  let result = '';\n  for (; offset < text.length; offset++) {\n    const char = text[offset];\n    switch (char) {\n      case '(':\n        ++nesting;\n        break;\n      case ')':\n        --nesting;\n        break;\n    }\n    result += char;\n    if (nesting === 0) {\n      return result;\n    }\n  }\n  throw new Error(`Mismatched parenthesis starting at offset ${offset}`);\n}\n\nexport function tokenizeBy(text: string, grammar = TOKENS): Tokens[] {\n  if (!text) {\n    return [];\n  }\n\n  const tokens: (Tokens | string)[] = [text];\n  for (const type in grammar) {\n    const pattern = grammar[type];\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      if (typeof token !== 'string') {\n        continue;\n      }\n\n      pattern.lastIndex = 0;\n      const match = pattern.exec(token);\n      if (!match) {\n        continue;\n      }\n\n      const from = match.index - 1;\n      const args: (Tokens | string)[] = [];\n      const content = match[0];\n\n      const before = token.slice(0, from + 1);\n      if (before) {\n        args.push(before);\n      }\n\n      args.push({\n        ...(match.groups as unknown as Tokens),\n        type,\n        content\n      });\n\n      const after = token.slice(from + content.length + 1);\n      if (after) {\n        args.push(after);\n      }\n\n      tokens.splice(i, 1, ...args);\n    }\n  }\n\n  let offset = 0;\n  for (const token of tokens) {\n    switch (typeof token) {\n      case 'string':\n        throw new Error(\n          `Unexpected sequence ${token} found at index ${offset}`\n        );\n      case 'object':\n        offset += token.content.length;\n        token.pos = [offset - token.content.length, offset];\n        if (TOKENS_TO_TRIM.has(token.type)) {\n          token.content = token.content.trim() || ' ';\n        }\n        break;\n    }\n  }\n\n  return tokens as Tokens[];\n}\n\nconst STRING_PATTERN = /(['\"])((?:\\\\.|\\\\\\n|[^\\\\\\n])+?)\\1/g;\nexport function tokenize(selector: string, grammar = TOKENS) {\n  type TokenString = { value: string; offset: number };\n\n  if (!selector) {\n    return null;\n  }\n\n  // Prevent leading/trailing whitespace be interpreted as combinators\n  selector = selector.trim();\n\n  // Replace strings with whitespace strings (to preserve offsets)\n  const stringExpressions: TokenString[] = [];\n  selector = selector.replace(\n    STRING_PATTERN,\n    (value: string, quote: string, content: string, offset: number) => {\n      stringExpressions.push({ value, offset });\n      return `${quote}${'§'.repeat(content.length)}${quote}`;\n    }\n  );\n\n  // Now that strings are out of the way, extract parens and replace them with parens with whitespace (to preserve offsets)\n  const parenthesisExpressions: TokenString[] = [];\n  {\n    let pos = 0;\n    let offset: number;\n    while ((offset = selector.indexOf('(', pos)) > -1) {\n      const value = scanParentheses(selector, offset);\n      parenthesisExpressions.push({ value, offset });\n      selector = `${selector.substring(0, offset)}(${'¶'.repeat(\n        value.length - 2\n      )})${selector.substring(offset + value.length)}`;\n      pos = offset + value.length;\n    }\n  }\n\n  // Now we have no nested structures and we can parse with regexes\n  const tokens = tokenizeBy(selector, grammar);\n\n  // Now restore parens and strings in reverse order\n  function restoreNested(\n    strings: TokenString[],\n    regex: RegExp,\n    types: Set<string>\n  ) {\n    for (const str of strings) {\n      for (const token of tokens) {\n        if (\n          !types.has(token.type) ||\n          token.pos[0] >= str.offset ||\n          str.offset >= token.pos[1]\n        ) {\n          continue;\n        }\n        const content = token.content;\n        token.content = token.content.replace(regex, str.value);\n        if (token.content !== content) {\n          // actually changed?\n          // Re-evaluate groups\n          TOKENS_FOR_RESTORE[token.type].lastIndex = 0;\n          const match = TOKENS_FOR_RESTORE[token.type].exec(token.content);\n          Object.assign(token, match!.groups);\n        }\n      }\n    }\n  }\n\n  restoreNested(parenthesisExpressions, /\\(¶+\\)/, TOKENS_WITH_PARENS);\n  restoreNested(stringExpressions, /(['\"])§+?\\1/, TOKENS_WITH_STRINGS);\n\n  return tokens;\n}\n\n/**\n *  Convert a flat list of tokens into a tree of complex & compound selectors\n */\nfunction nestTokens(tokens: Tokens[], { list = true } = {}): AST {\n  if (list && tokens.find((t: { type: string }) => t.type === 'comma')) {\n    const selectors: AST[] = [];\n    const temp = [];\n\n    for (let i = 0; i < tokens.length; i++) {\n      if (tokens[i].type === 'comma') {\n        if (temp.length === 0) {\n          throw new Error('Incorrect comma at ' + i);\n        }\n\n        selectors.push(nestTokens(temp, { list: false }));\n        temp.length = 0;\n      } else {\n        temp.push(tokens[i]);\n      }\n    }\n\n    if (temp.length === 0) {\n      throw new Error('Trailing comma');\n    } else {\n      selectors.push(nestTokens(temp, { list: false }));\n    }\n\n    return { type: 'list', list: selectors };\n  }\n\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    let token = tokens[i];\n\n    if (token.type === 'combinator') {\n      let left = tokens.slice(0, i);\n      let right = tokens.slice(i + 1);\n\n      return {\n        type: 'complex',\n        combinator: token.content,\n        left: nestTokens(left),\n        right: nestTokens(right)\n      };\n    }\n  }\n\n  switch (tokens.length) {\n    case 0:\n      throw new Error('Could not build AST.');\n    case 1:\n      // If we're here, there are no combinators, so it's just a list.\n      return tokens[0];\n    default:\n      return {\n        type: 'compound',\n        list: [...tokens] // clone to avoid pointers messing up the AST\n      };\n  }\n}\n\n/**\n * Traverse an AST (or part thereof), in depth-first order\n */\nexport function walk(\n  node: AST | undefined,\n  visit: (node: AST, parentNode?: AST) => void,\n  /**\n   * @internal\n   */\n  parent?: AST\n) {\n  if (!node) {\n    return;\n  }\n\n  if ('left' in node && 'right' in node) {\n    walk(node.left, visit, node);\n    walk(node.right, visit, node);\n  } else if ('list' in node) {\n    for (let n of node.list) {\n      walk(n, visit, node);\n    }\n  }\n\n  visit(node, parent);\n}\n\nexport interface ParserOptions {\n  recursive?: boolean;\n  list?: boolean;\n}\n\n/**\n * Parse a CSS selector\n *\n * @param selector - The selector to parse\n * @param options.recursive - Whether to parse the arguments of pseudo-classes like :is(), :has() etc. Defaults to true.\n * @param options.list - Whether this can be a selector list (A, B, C etc). Defaults to true.\n */\nexport function parse(\n  selector: string,\n  { recursive = true, list = true }: ParserOptions = {}\n): AST | undefined {\n  const tokens = tokenize(selector);\n  if (!tokens) {\n    return;\n  }\n\n  const ast = nestTokens(tokens, { list });\n\n  if (!recursive) {\n    return ast;\n  }\n\n  walk(ast, (node) => {\n    if (node.type === TokenType.PseudoClass && node.argument) {\n      if (RECURSIVE_PSEUDO_CLASSES.has(node.name)) {\n        let argument = node.argument;\n        const childArg = RECURSIVE_PSEUDO_CLASSES_ARGS[node.name];\n        if (childArg) {\n          const match = childArg.exec(argument);\n          if (!match) {\n            return;\n          }\n\n          Object.assign(node, match.groups);\n          argument = match.groups!['subtree'];\n        }\n        if (argument) {\n          Object.assign(node, {\n            subtree: parse(argument, { recursive: true, list: true })\n          });\n        }\n      }\n    }\n  });\n\n  return ast;\n}\n\n/**\n * To convert the specificity array to a number\n */\nexport function specificityToNumber(\n  specificity: number[],\n  base: number\n): number {\n  base = base || Math.max(...specificity) + 1;\n  return specificity[0] * (base << 1) + specificity[1] * base + specificity[2];\n}\n\n/**\n * Calculate specificity of a selector.\n *\n * If the selector is a list, the max specificity is returned.\n */\nexport function specificity(selector: string | AST): number[] {\n  let ast: string | AST | undefined = selector;\n  if (typeof ast === 'string') {\n    ast = parse(ast, { recursive: true });\n  }\n  if (!ast) {\n    return [];\n  }\n\n  if (ast.type === 'list' && 'list' in ast) {\n    let base = 10;\n    const specificities = ast.list.map((ast) => {\n      const sp = specificity(ast);\n      base = Math.max(base, ...specificity(ast));\n      return sp;\n    });\n    const numbers = specificities.map((ast) => specificityToNumber(ast, base));\n    return specificities[numbers.indexOf(Math.max(...numbers))];\n  }\n\n  let ret = [0, 0, 0];\n  walk(ast, (node) => {\n    if (node.type === 'id') {\n      ret[0]++;\n    } else if (node.type === 'class' || node.type === 'attribute') {\n      ret[1]++;\n    } else if (\n      (node.type === 'type' && node.content !== '*') ||\n      node.type === 'pseudo-element'\n    ) {\n      ret[2]++;\n    } else if (node.type === 'pseudo-class' && node.name !== 'where') {\n      if (RECURSIVE_PSEUDO_CLASSES.has(node.name) && node.subtree) {\n        const sub = specificity(node.subtree);\n        sub.forEach((s, i) => (ret[i] += s));\n        // :nth-child() & :nth-last-child() add (0, 1, 0) to the specificity of their most complex selector\n        if (node.name === 'nth-child' || node.name === 'nth-last-child') {\n          ret[1]++;\n        }\n      } else {\n        ret[1]++;\n      }\n    }\n  });\n\n  return ret;\n}\n"],"names":["TokenType"],"mappings":"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"}