"use strict";var e;Object.defineProperty(exports,"__esModule",{value:!0}),exports.TokenType=void 0,(e=exports.TokenType||(exports.TokenType={})).Class="class",e.Attribute="attribute",e.Id="id",e.Type="type",e.Universal="universal",e.PseudoElement="pseudo-element",e.PseudoClass="pseudo-class",e.Comma="comma",e.Combinator="combinator";const t={[exports.TokenType.Attribute]:/\[\s*(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,[exports.TokenType.Id]:/#(?<name>(?:\\.|[-\w\u{0080}-\u{FFFF}])+)/gu,[exports.TokenType.Class]:/\.(?<name>(?:\\.|[-\w\u{0080}-\u{FFFF}])+)/gu,[exports.TokenType.Comma]:/\s*,\s*/g,[exports.TokenType.Combinator]:/\s*[\s>+~]\s*/g,[exports.TokenType.PseudoElement]:/::(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?<argument>¶+)\))?/gu,[exports.TokenType.PseudoClass]:/:(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?<argument>¶+)\))?/gu,[exports.TokenType.Universal]:/(?:(?<namespace>\*|[-\w]*)\|)?\*/gu,[exports.TokenType.Type]:/(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)|\*/gu},n=new Set([exports.TokenType.PseudoClass,exports.TokenType.PseudoElement]),s=new Set([...n,exports.TokenType.Attribute]),o=new Set([exports.TokenType.Combinator,exports.TokenType.Comma]),r=new Set(["not","is","where","has","matches","-moz-any","-webkit-any","nth-child","nth-last-child"]),i=/(?<index>[\dn+-]+)\s+of\s+(?<subtree>.+)/,p={"nth-child":i,"nth-last-child":i},c={...t};for(const e of[exports.TokenType.PseudoElement,exports.TokenType.PseudoClass])c[e]=RegExp(t[e].source.replace("(?<argument>¶+)","(?<argument>.+)"),"gu");function u(e,t){let n=0,s="";for(;t<e.length;t++){const o=e[t];switch(o){case"(":++n;break;case")":--n}if(s+=o,0===n)return s}throw new Error(`Mismatched parenthesis starting at offset ${t}`)}function a(e,n=t){if(!e)return[];const s=[e];for(const e in n){const t=n[e];for(let n=0;n<s.length;n++){const o=s[n];if("string"!=typeof o)continue;t.lastIndex=0;const r=t.exec(o);if(!r)continue;const i=r.index-1,p=[],c=r[0],u=o.slice(0,i+1);u&&p.push(u),p.push({...r.groups,type:e,content:c});const a=o.slice(i+c.length+1);a&&p.push(a),s.splice(n,1,...p)}}let r=0;for(const e of s)switch(typeof e){case"string":throw new Error(`Unexpected sequence ${e} found at index ${r}`);case"object":r+=e.content.length,e.pos=[r-e.content.length,r],o.has(e.type)&&(e.content=e.content.trim()||" ")}return s}const l=/(['"])((?:\\.|\\\n|[^\\\n])+?)\1/g;function f(e,o=t){if(!e)return null;e=e.trim();const r=[];e=e.replace(l,((e,t,n,s)=>(r.push({value:e,offset:s}),`${t}${"§".repeat(n.length)}${t}`)));const i=[];{let t,n=0;for(;(t=e.indexOf("(",n))>-1;){const s=u(e,t);i.push({value:s,offset:t}),e=`${e.substring(0,t)}(${"¶".repeat(s.length-2)})${e.substring(t+s.length)}`,n=t+s.length}}const p=a(e,o);function f(e,t,n){for(const s of e)for(const e of p){if(!n.has(e.type)||e.pos[0]>=s.offset||s.offset>=e.pos[1])continue;const o=e.content;if(e.content=e.content.replace(t,s.value),e.content!==o){c[e.type].lastIndex=0;const t=c[e.type].exec(e.content);Object.assign(e,t.groups)}}}return f(i,/\(¶+\)/,n),f(r,/(['"])§+?\1/,s),p}function m(e,{list:t=!0}={}){if(t&&e.find((e=>"comma"===e.type))){const t=[],n=[];for(let s=0;s<e.length;s++)if("comma"===e[s].type){if(0===n.length)throw new Error("Incorrect comma at "+s);t.push(m(n,{list:!1})),n.length=0}else n.push(e[s]);if(0===n.length)throw new Error("Trailing comma");return t.push(m(n,{list:!1})),{type:"list",list:t}}for(let t=e.length-1;t>=0;t--){let n=e[t];if("combinator"===n.type){let s=e.slice(0,t),o=e.slice(t+1);return{type:"complex",combinator:n.content,left:m(s),right:m(o)}}}switch(e.length){case 0:throw new Error("Could not build AST.");case 1:return e[0];default:return{type:"compound",list:[...e]}}}function h(e,t,n){if(e){if("left"in e&&"right"in e)h(e.left,t,e),h(e.right,t,e);else if("list"in e)for(let n of e.list)h(n,t,e);t(e,n)}}function T(e,{recursive:t=!0,list:n=!0}={}){const s=f(e);if(!s)return;const o=m(s,{list:n});return t?(h(o,(e=>{if(e.type===exports.TokenType.PseudoClass&&e.argument&&r.has(e.name)){let t=e.argument;const n=p[e.name];if(n){const s=n.exec(t);if(!s)return;Object.assign(e,s.groups),t=s.groups.subtree}t&&Object.assign(e,{subtree:T(t,{recursive:!0,list:!0})})}})),o):o}function y(e,t){return t=t||Math.max(...e)+1,e[0]*(t<<1)+e[1]*t+e[2]}exports.RECURSIVE_PSEUDO_CLASSES=r,exports.RECURSIVE_PSEUDO_CLASSES_ARGS=p,exports.TOKENS=t,exports.TOKENS_TO_TRIM=o,exports.TOKENS_WITH_PARENS=n,exports.TOKENS_WITH_STRINGS=s,exports.parse=T,exports.specificity=function e(t){let n=t;if("string"==typeof n&&(n=T(n,{recursive:!0})),!n)return[];if("list"===n.type&&"list"in n){let t=10;const s=n.list.map((n=>{const s=e(n);return t=Math.max(t,...e(n)),s})),o=s.map((e=>y(e,t)));return s[o.indexOf(Math.max(...o))]}let s=[0,0,0];return h(n,(t=>{if("id"===t.type)s[0]++;else if("class"===t.type||"attribute"===t.type)s[1]++;else if("type"===t.type&&"*"!==t.content||"pseudo-element"===t.type)s[2]++;else if("pseudo-class"===t.type&&"where"!==t.name)if(r.has(t.name)&&t.subtree){e(t.subtree).forEach(((e,t)=>s[t]+=e)),"nth-child"!==t.name&&"nth-last-child"!==t.name||s[1]++}else s[1]++})),s},exports.specificityToNumber=y,exports.tokenize=f,exports.tokenizeBy=a,exports.walk=h;
//# sourceMappingURL=parsel.min.js.map
