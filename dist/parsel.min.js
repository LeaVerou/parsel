const e={attribute:/\[\s*(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,id:/#(?<name>(?:[-\w\u{0080}-\u{FFFF}]|\\.)+)/gu,class:/\.(?<name>(?:[-\w\u{0080}-\u{FFFF}]|\\.)+)/gu,comma:/\s*,\s*/g,combinator:/\s*[\s>+~]\s*/g,"pseudo-element":/::(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?<argument>¶+)\))?/gu,"pseudo-class":/:(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?<argument>¶+)\))?/gu,universal:/(?:(?<namespace>\*|[-\w]*)\|)?\*/gu,type:/(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)|\*/gu},t=new Set(["pseudo-class","pseudo-element"]),n=new Set([...t,"attribute"]),r=new Set(["combinator","comma"]),s=new Set(["not","is","where","has","matches","-moz-any","-webkit-any","nth-child","nth-last-child"]),l={"nth-child":/(?<index>[\dn+-]+)\s+of\s+(?<subtree>.+)/};s["nth-last-child"]=l["nth-child"];const u=Object.assign({},e);function o(e,t){let n="",r=[];for(;t<e.length;t++){let s=e[t];if("("===s)r.push(s);else if(")"===s){if(!(r.length>0))throw new Error("Closing paren without opening paren at "+t);r.pop()}if(n+=s,0===r.length)return n}throw new Error("Opening paren without closing paren")}function i(e,t){if(!e)return[];var n=[e];for(var s in t){let e=t[s];for(var l=0;l<n.length;l++){var u=n[l];if("string"==typeof u){e.lastIndex=0;var o=e.exec(u);if(o){let e=o.index-1,t=[],r=o[0],i=u.slice(0,e+1);i&&t.push(i),t.push({type:s,content:r,...o.groups});let a=u.slice(e+r.length+1);a&&t.push(a),n.splice(l,1,...t)}}}}let i=0;for(let e=0;e<n.length;e++){let t=n[e],s=t.length||t.content.length;"object"==typeof t&&(t.pos=[i,i+s],r.has(t.type)&&(t.content=t.content.trim()||" ")),i+=s}return n}function a(r){if(!r)return null;r=r.trim();let s=[];r=r.replace(/(['"])((?:\\\1|.)+?)\1/g,((e,t,n,r)=>(s.push({str:e,start:r}),t+"§".repeat(n.length)+t)));let l,a=[],c=0;for(;(l=r.indexOf("(",c))>-1;){let e=o(r,l);a.push({str:e,start:l}),r=r.substring(0,l)+"("+"¶".repeat(e.length-2)+")"+r.substring(l+e.length),c=l+e.length}let p=i(r,e);function f(e,t,n){for(let r of e)for(let e of p)if(n.has(e.type)&&e.pos[0]<r.start&&r.start<e.pos[1]){let n=e.content;if(e.content=e.content.replace(t,r.str),e.content!==n){u[e.type].lastIndex=0;let t=u[e.type].exec(e.content).groups;Object.assign(e,t)}}}return f(a,/\(¶+\)/,t),f(s,/(['"])§+?\1/,n),p}function c(e,{list:t=!0}={}){if(t&&e.find((e=>"comma"===e.type))){let t=[],n=[];for(let r=0;r<e.length;r++)if("comma"===e[r].type){if(0===n.length)throw new Error("Incorrect comma at "+r);t.push(c(n,{list:!1})),n.length=0}else n.push(e[r]);if(0===n.length)throw new Error("Trailing comma");return t.push(c(n,{list:!1})),{type:"list",list:t}}for(let t=e.length-1;t>=0;t--){let n=e[t];if("combinator"===n.type){let r=e.slice(0,t),s=e.slice(t+1);return{type:"complex",combinator:n.content,left:c(r),right:c(s)}}}return 0===e.length?null:1===e.length?e[0]:{type:"compound",list:[...e]}}function p(e,t,n,r){if(e){if("complex"===e.type)p(e.left,t,n,e),p(e.right,t,n,e);else if("compound"===e.type||"list"===e.type)for(let r of e.list)p(r,t,n,e);else e.subtree&&n&&n.subtree&&p(e.subtree,t,n,e);t(e,r)}}function f(e,{recursive:t=!0,list:n=!0}={}){let r=a(e);if(!r)return null;let u=c(r,{list:n});return t&&p(u,(e=>{if("pseudo-class"===e.type&&e.argument&&s.has(e.name)){let t=e.argument;const n=l[e.name];if(n){const r=n.exec(t);if(!r)return;Object.assign(e,r.groups),t=r.groups.subtree}t&&(e.subtree=f(t,{recursive:!0,list:!0}))}})),u}function h(e,t){return t=t||Math.max(...e)+1,e[0]*t**2+e[1]*t+e[2]}function g(e,{format:t="array"}={}){let n="object"==typeof e?e:f(e,{recursive:!0});if(!n)return null;if("list"===n.type){let e=10,t=n.list.map((t=>{let n=g(t);return e=Math.max(e,...n),n})),r=t.map((t=>h(t,e)));return t[function(e){let t=e[0],n=0;for(let r=0;r<e.length;r++)e[r]>t&&(n=r,t=e[r]);return 0===e.length?-1:n}(r)]}let r=[0,0,0];return p(n,(e=>{if("id"===e.type)r[0]++;else if("class"===e.type||"attribute"===e.type)r[1]++;else if("type"===e.type&&"*"!==e.content||"pseudo-element"===e.type)r[2]++;else if("pseudo-class"===e.type&&"where"!==e.name)if(s.has(e.name)&&e.subtree){g(e.subtree).forEach(((e,t)=>r[t]+=e)),"nth-child"!==e.name&&"nth-last-child"!==e.name||r[1]++}else r[1]++})),r}u["pseudo-element"]=RegExp(e["pseudo-element"].source.replace("(?<argument>¶+)","(?<argument>.+?)"),"gu"),u["pseudo-class"]=RegExp(e["pseudo-class"].source.replace("(?<argument>¶+)","(?<argument>.+)"),"gu");export{s as RECURSIVE_PSEUDO_CLASSES,l as RECURSIVE_PSEUDO_CLASSES_ARGS,e as TOKENS,r as TRIM_TOKENS,o as gobbleParens,c as nestTokens,f as parse,g as specificity,h as specificityToNumber,a as tokenize,i as tokenizeBy,p as walk};
