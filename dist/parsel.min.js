var e;!function(e){e.Class="class",e.Attribute="attribute",e.Id="id",e.Type="type",e.Universal="universal",e.PseudoElement="pseudo-element",e.PseudoClass="pseudo-class",e.Comma="comma",e.Combinator="combinator"}(e||(e={}));const t={[e.Attribute]:/\[\s*(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,[e.Id]:/#(?<name>(?:\\.|[-\w\u{0080}-\u{FFFF}])+)/gu,[e.Class]:/\.(?<name>(?:\\.|[-\w\u{0080}-\u{FFFF}])+)/gu,[e.Comma]:/\s*,\s*/g,[e.Combinator]:/\s*[\s>+~]\s*/g,[e.PseudoElement]:/::(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?<argument>¶+)\))?/gu,[e.PseudoClass]:/:(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?<argument>¶+)\))?/gu,[e.Universal]:/(?:(?<namespace>\*|[-\w]*)\|)?\*/gu,[e.Type]:/(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)|\*/gu},n=new Set([e.PseudoClass,e.PseudoElement]),s=new Set([...n,e.Attribute]),o=new Set([e.Combinator,e.Comma]),r=new Set(["not","is","where","has","matches","-moz-any","-webkit-any","nth-child","nth-last-child"]),i=/(?<index>[\dn+-]+)\s+of\s+(?<subtree>.+)/,c={"nth-child":i,"nth-last-child":i},u={...t};for(const n of[e.PseudoElement,e.PseudoClass])u[n]=RegExp(t[n].source.replace("(?<argument>¶+)","(?<argument>.+)"),"gu");function a(e,t){let n=0,s="";for(;t<e.length;t++){const o=e[t];switch(o){case"(":++n;break;case")":--n}if(s+=o,0===n)return s}throw new Error(`Mismatched parenthesis starting at offset ${t}`)}function l(e,n=t){if(!e)return[];const s=[e];for(const e in n){const t=n[e];for(let n=0;n<s.length;n++){const o=s[n];if("string"!=typeof o)continue;t.lastIndex=0;const r=t.exec(o);if(!r)continue;const i=r.index-1,c=[],u=r[0],a=o.slice(0,i+1);a&&c.push(a),c.push({...r.groups,type:e,content:u});const l=o.slice(i+u.length+1);l&&c.push(l),s.splice(n,1,...c)}}let r=0;for(const e of s)switch(typeof e){case"string":throw new Error(`Unexpected sequence ${e} found at index ${r}`);case"object":r+=e.content.length,e.pos=[r-e.content.length,r],o.has(e.type)&&(e.content=e.content.trim()||" ")}return s}const f=/(['"])((?:\\.|\\\n|[^\\\n])+?)\1/g;function p(e,o=t){if(!e)return null;e=e.trim();const r=[];e=e.replace(f,((e,t,n,s)=>(r.push({value:e,offset:s}),`${t}${"§".repeat(n.length)}${t}`)));const i=[];{let t,n=0;for(;(t=e.indexOf("(",n))>-1;){const s=a(e,t);i.push({value:s,offset:t}),e=`${e.substring(0,t)}(${"¶".repeat(s.length-2)})${e.substring(t+s.length)}`,n=t+s.length}}const c=l(e,o);function p(e,t,n){for(const s of e)for(const e of c){if(!n.has(e.type)||e.pos[0]>=s.offset||s.offset>=e.pos[1])continue;const o=e.content;if(e.content=e.content.replace(t,s.value),e.content!==o){u[e.type].lastIndex=0;const t=u[e.type].exec(e.content);Object.assign(e,t.groups)}}}return p(i,/\(¶+\)/,n),p(r,/(['"])§+?\1/,s),c}function m(e,{list:t=!0}={}){if(t&&e.find((e=>"comma"===e.type))){const t=[],n=[];for(let s=0;s<e.length;s++)if("comma"===e[s].type){if(0===n.length)throw new Error("Incorrect comma at "+s);t.push(m(n,{list:!1})),n.length=0}else n.push(e[s]);if(0===n.length)throw new Error("Trailing comma");return t.push(m(n,{list:!1})),{type:"list",list:t}}for(let t=e.length-1;t>=0;t--){let n=e[t];if("combinator"===n.type){let s=e.slice(0,t),o=e.slice(t+1);return{type:"complex",combinator:n.content,left:m(s),right:m(o)}}}switch(e.length){case 0:throw new Error("Could not build AST.");case 1:return e[0];default:return{type:"compound",list:[...e]}}}function h(e,t,n){if(e){if("left"in e&&"right"in e)h(e.left,t,e),h(e.right,t,e);else if("list"in e)for(let n of e.list)h(n,t,e);t(e,n)}}function g(t,{recursive:n=!0,list:s=!0}={}){const o=p(t);if(!o)return;const i=m(o,{list:s});return n?(h(i,(t=>{if(t.type===e.PseudoClass&&t.argument&&r.has(t.name)){let e=t.argument;const n=c[t.name];if(n){const s=n.exec(e);if(!s)return;Object.assign(t,s.groups),e=s.groups.subtree}e&&Object.assign(t,{subtree:g(e,{recursive:!0,list:!0})})}})),i):i}function d(e,t){return t=t||Math.max(...e)+1,e[0]*(t<<1)+e[1]*t+e[2]}function w(e){let t=e;if("string"==typeof t&&(t=g(t,{recursive:!0})),!t)return[];if("list"===t.type&&"list"in t){let e=10;const n=t.list.map((t=>{const n=w(t);return e=Math.max(e,...w(t)),n})),s=n.map((t=>d(t,e)));return n[s.indexOf(Math.max(...s))]}let n=[0,0,0];return h(t,(e=>{if("id"===e.type)n[0]++;else if("class"===e.type||"attribute"===e.type)n[1]++;else if("type"===e.type&&"*"!==e.content||"pseudo-element"===e.type)n[2]++;else if("pseudo-class"===e.type&&"where"!==e.name)if(r.has(e.name)&&e.subtree){w(e.subtree).forEach(((e,t)=>n[t]+=e)),"nth-child"!==e.name&&"nth-last-child"!==e.name||n[1]++}else n[1]++})),n}export{r as RECURSIVE_PSEUDO_CLASSES,c as RECURSIVE_PSEUDO_CLASSES_ARGS,t as TOKENS,o as TOKENS_TO_TRIM,n as TOKENS_WITH_PARENS,s as TOKENS_WITH_STRINGS,e as TokenType,g as parse,w as specificity,d as specificityToNumber,p as tokenize,l as tokenizeBy,h as walk};
//# sourceMappingURL=parsel.min.js.map
