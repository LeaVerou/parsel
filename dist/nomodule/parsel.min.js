var parsel=function(e){"use strict";var t;e.TokenType=void 0,(t=e.TokenType||(e.TokenType={})).Class="class",t.Attribute="attribute",t.Id="id",t.Type="type",t.Universal="universal",t.PseudoElement="pseudo-element",t.PseudoClass="pseudo-class",t.Comma="comma",t.Combinator="combinator";const n={[e.TokenType.Attribute]:/\[\s*(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,[e.TokenType.Id]:/#(?<name>(?:\\.|[-\w\u{0080}-\u{FFFF}])+)/gu,[e.TokenType.Class]:/\.(?<name>(?:\\.|[-\w\u{0080}-\u{FFFF}])+)/gu,[e.TokenType.Comma]:/\s*,\s*/g,[e.TokenType.Combinator]:/\s*[\s>+~]\s*/g,[e.TokenType.PseudoElement]:/::(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?<argument>¶+)\))?/gu,[e.TokenType.PseudoClass]:/:(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?<argument>¶+)\))?/gu,[e.TokenType.Universal]:/(?:(?<namespace>\*|[-\w]*)\|)?\*/gu,[e.TokenType.Type]:/(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)|\*/gu},s=new Set([e.TokenType.PseudoClass,e.TokenType.PseudoElement]),o=new Set([...s,e.TokenType.Attribute]),r=new Set([e.TokenType.Combinator,e.TokenType.Comma]),i=new Set(["not","is","where","has","matches","-moz-any","-webkit-any","nth-child","nth-last-child"]),c=/(?<index>[\dn+-]+)\s+of\s+(?<subtree>.+)/,u={"nth-child":c,"nth-last-child":c},a={...n};for(const t of[e.TokenType.PseudoElement,e.TokenType.PseudoClass])a[t]=RegExp(n[t].source.replace("(?<argument>¶+)","(?<argument>.+)"),"gu");function l(e,t){let n=0,s="";for(;t<e.length;t++){const o=e[t];switch(o){case"(":++n;break;case")":--n}if(s+=o,0===n)return s}throw new Error(`Mismatched parenthesis starting at offset ${t}`)}function p(e,t=n){if(!e)return[];const s=[e];for(const e in t){const n=t[e];for(let t=0;t<s.length;t++){const o=s[t];if("string"!=typeof o)continue;n.lastIndex=0;const r=n.exec(o);if(!r)continue;const i=r.index-1,c=[],u=r[0],a=o.slice(0,i+1);a&&c.push(a),c.push({...r.groups,type:e,content:u});const l=o.slice(i+u.length+1);l&&c.push(l),s.splice(t,1,...c)}}let o=0;for(const e of s)switch(typeof e){case"string":throw new Error(`Unexpected sequence ${e} found at index ${o}`);case"object":o+=e.content.length,e.pos=[o-e.content.length,o],r.has(e.type)&&(e.content=e.content.trim()||" ")}return s}const f=/(['"])((?:\\.|\\\n|[^\\\n])+?)\1/g;function m(e,t=n){if(!e)return null;e=e.trim();const r=[];e=e.replace(f,((e,t,n,s)=>(r.push({value:e,offset:s}),`${t}${"§".repeat(n.length)}${t}`)));const i=[];{let t,n=0;for(;(t=e.indexOf("(",n))>-1;){const s=l(e,t);i.push({value:s,offset:t}),e=`${e.substring(0,t)}(${"¶".repeat(s.length-2)})${e.substring(t+s.length)}`,n=t+s.length}}const c=p(e,t);function u(e,t,n){for(const s of e)for(const e of c){if(!n.has(e.type)||e.pos[0]>=s.offset||s.offset>=e.pos[1])continue;const o=e.content;if(e.content=e.content.replace(t,s.value),e.content!==o){a[e.type].lastIndex=0;const t=a[e.type].exec(e.content);Object.assign(e,t.groups)}}}return u(i,/\(¶+\)/,s),u(r,/(['"])§+?\1/,o),c}function h(e,{list:t=!0}={}){if(t&&e.find((e=>"comma"===e.type))){const t=[],n=[];for(let s=0;s<e.length;s++)if("comma"===e[s].type){if(0===n.length)throw new Error("Incorrect comma at "+s);t.push(h(n,{list:!1})),n.length=0}else n.push(e[s]);if(0===n.length)throw new Error("Trailing comma");return t.push(h(n,{list:!1})),{type:"list",list:t}}for(let t=e.length-1;t>=0;t--){let n=e[t];if("combinator"===n.type){let s=e.slice(0,t),o=e.slice(t+1);return{type:"complex",combinator:n.content,left:h(s),right:h(o)}}}switch(e.length){case 0:throw new Error("Could not build AST.");case 1:return e[0];default:return{type:"compound",list:[...e]}}}function T(e,t,n){if(e){if("left"in e&&"right"in e)T(e.left,t,e),T(e.right,t,e);else if("list"in e)for(let n of e.list)T(n,t,e);t(e,n)}}function y(t,{recursive:n=!0,list:s=!0}={}){const o=m(t);if(!o)return;const r=h(o,{list:s});return n?(T(r,(t=>{if(t.type===e.TokenType.PseudoClass&&t.argument&&i.has(t.name)){let e=t.argument;const n=u[t.name];if(n){const s=n.exec(e);if(!s)return;Object.assign(t,s.groups),e=s.groups.subtree}e&&Object.assign(t,{subtree:y(e,{recursive:!0,list:!0})})}})),r):r}function g(e,t){return t=t||Math.max(...e)+1,e[0]*(t<<1)+e[1]*t+e[2]}return e.RECURSIVE_PSEUDO_CLASSES=i,e.RECURSIVE_PSEUDO_CLASSES_ARGS=u,e.TOKENS=n,e.TOKENS_TO_TRIM=r,e.TOKENS_WITH_PARENS=s,e.TOKENS_WITH_STRINGS=o,e.parse=y,e.specificity=function e(t){let n=t;if("string"==typeof n&&(n=y(n,{recursive:!0})),!n)return[];if("list"===n.type&&"list"in n){let t=10;const s=n.list.map((n=>{const s=e(n);return t=Math.max(t,...e(n)),s})),o=s.map((e=>g(e,t)));return s[o.indexOf(Math.max(...o))]}let s=[0,0,0];return T(n,(t=>{if("id"===t.type)s[0]++;else if("class"===t.type||"attribute"===t.type)s[1]++;else if("type"===t.type&&"*"!==t.content||"pseudo-element"===t.type)s[2]++;else if("pseudo-class"===t.type&&"where"!==t.name)if(i.has(t.name)&&t.subtree){e(t.subtree).forEach(((e,t)=>s[t]+=e)),"nth-child"!==t.name&&"nth-last-child"!==t.name||s[1]++}else s[1]++})),s},e.specificityToNumber=g,e.tokenize=m,e.tokenizeBy=p,e.walk=T,Object.defineProperty(e,"__esModule",{value:!0}),e}({});
//# sourceMappingURL=parsel.min.js.map
